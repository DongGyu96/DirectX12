커맨드 큐에 커맨드 리스트를 추가하려면 커맨드를 담을 메모리가 필요하기 때문에
커맨드 Allocator를 생성 커맨드 Allocator에는 커맨드들이 담겨있음
반드시 Execute는 실행이 아니라는 점을 기억해야함

CommandList의 3가지 타입
1. Copy
2. Direct (직접 실행) 명령 리스트
	이번 학기에서는 다이렉트 명령 리스트를 주로 배움
	
3. Compute (계산 쉐이더에 주로 씀)

Direct3D Device를 사용하는 방법은 Set & Draw 
( 그래픽스 커맨드리스트가 가지고있음 )
원하는 상태로 Set하고 원하는 상태가 되었다고 판단이 되면 Draw

커맨드리스트를 만들었다면 그 커맨드 리스트에 명령들을 추가하는것은
그래픽스 커맨드리스트에 있는 Set함수들을 호출하는 것
함수들을 호출한다고 해서 바로 실행이 되는 것이 아니라 커맨드 리스트에
명령이 쓰여지기만 하는 것 ( 가르키는 포인터의 리스트 개념 )
GPU에 전달하기 위해 커맨드 큐에 전달해야만 함 Execute함수 호출
GPU가 차례대로 명령들을 실행하다보면 언젠간 차례가 옴 ( 순서를 기다림 )

커맨드 리스트가 만들어지면 2가지 중요한 함수가 있음
만들어지면 초기 상태는 Open 상태 ( 명령어를 추가 할 것이라는 의사 표현 )
Reset
리스트를 재활용 할 것이라는 의사 표현 ( 명령어를 추가 할 수 있는 상태 )
Close
명령어를 더이상 추가하지 않을 것이라는 의사 표현
Reset -> Set -> Close -> Execute 반복

커맨드 Allocator에는 실제 명령어들이 들어가 있고
커맨드 리스트에는 명령어들을 가르키는 포인터가 들어있기 때문에
커맨드 리스트를 리셋해도 명령어들은 변하지 않지만
Allocator를 Reset하면 명령어가 지워지게됨 따라서 커맨드 리스트도 망가짐
커맨드 Allocator는 커맨드 리스트가 실행중일때 리셋하면 안됨
새 프레임이 시작할때 둘다 리셋하는게 좋음

어떤 커맨드 리스트는 어떤 하나의 개념을 담고있는 커맨드들을 담고있음

어떤 그림을 그리려고 하면 그림에 대한 데이터가 필요 ( 리소스 )
비디오 메모리에 있는 모든 데이터들, GPU가 사용하는 데이터들을 의미
그림을 그리기 위해서 필요한 것 ( 리소스 데이터의 내용 )
1. 메쉬, 2. 행렬과 같은 데이터, 3. 텍스쳐 등등
명령과 리소스를 실제로 만들어 내는 주체는 CPU - Write
리소스를 읽어서 명령을 실행하는 주체는 GPU - Read
따라서 CPU와 GPU의 동기화가 필요함 ( 줄서기 )
그러나 그렇게 한다면 기다려야 함
CPU가 데이터를 만들어내면 GPU가 명령을 실행완료할때까지 기다리고
CPU가 늦게 만들어내면 GPU가 기다리게 됨
기다리는 시간을 없애는 방법은 현실적으로 힘듦 그렇기 떄문에

대기하는 시간을 줄여아 한다 (동기화를 하는 방법)
Direct3D에서는 펜스라고 하는 오브젝트를 사용 펜스란
어떤 리소스들을 접근하기 위해서 둘 사이에 줄을 세우는 방법으로 사용하는 객체
Fence 내부에는 int 변수 하나가 있음 ( 초기값 )
Flag는 공유 펜스를 사용하지 않을 것이기 때문에 기본 펜스인 0을 사용할 것

펜스 자체만 가지고는 동기화를 할수 없고 운영체제에서도 제공하는
CreateEvent라고 하는 동기화 오브젝트를 씀 (Win API 함수)
CreateEvent로 얻는 handle을 SetEventOnCompletion함수에서 사용

Event는 T,F의 bool값을 가지는데 False면 기다리고 있다가 True가
된다면 깨어나서 실행할 수 있게 함 
CPU는 GPU가 이 리소스를 다 읽어갔는지를 확인하고 다시 리소스를 써야 함
GPU가 명령리스트를 다 비우게 되면 리소스를 다 사용했다는 의미가 됨
Fence의 값을 지정된 어떤 값으로 증가 시켜 놓고(fence 내부의 int 값)
Direct3D에서 기다리고 있던 CPU를 깨워서 새로운 리소스와 명령을 집어넣고 
다시 기다리게 함 그렇게 하면 동기화가 됨
FenceValue는 프레임 번호라고 의미해도 됨

Fence->SetEventOnCompletion(fencevalue, event)
Fence의 value값이 fencevalue가 되면 event를 꺠우게 함
GPU가 모든 명령어를 실행했다는 것을 보장

CommandQueue::SIgnal함수는 Fence와 value를 인자로 받아
GPU가 펜스를 이 값으로 설정하는 명령을 명령큐에 추가하는 함수
큐에 마지막에는 펜스 = m + 1이 있어야 함


GPU에서 사용하는 프로그램 - 쉐이더
쉐이더가 사용하는 리소스 - 쉐이더 리소스 ( 텍스처, 이미지데이터 등 )
Texture 자료형에 MS가 붙은것은 멀티 샘플링을 지원하는 텍스쳐 자료형

리소스는 그림을 나타내는 데이터(텍스쳐)와 
그렇지 않는 데이터로 구분할 수 있음(버퍼)
후면버퍼 또한 텍스쳐라고 생각해도 됨

다이렉트3D에 파이프라인은 그래픽스 파이프라인과 계산 파이프라인으로 나뉨
계산파이프라인은 GPU가 가진 병렬처리를 사용해서 계산을 전용으로 하는 프로그램
에서 사용함 ( 2학기떄 다룸 )

모든 리소스들은 쉐이더가 직접 쓰는것이 아니라 리소스 뷰를 통해서만 접근
리소스 뷰란 리소스가 있으면 어떤 목적으로 사용할 것인지 알려줌
뷰 - 어떤 데이터를 설명하는 자료구조, 정보를 담고 있음
( 가로픽셀수, 세로픽셀수, 포맷 등등 ), 또한
텍스처가 비디오 메모리 어디에 있는지에 대한 포인터를 가짐

1. 리소스를 만들어야함 디바이스 인터페이스의 Create함수
2. 뷰를 만들어야함 그래픽스커맨드리스트의 Set .... View 함수

뷰의 종류들 ( 샘플러도 뷰 )
각각의 뷰를 통해서 리소스를 접근하도록 만들어야 함

펜스의 값과 CPU의 펜스값을 0, 0으로 만듬
CPU가 명령을 다 만들어내면 자신의 펜스값을 1 올림 Event를 만들어서 Wait
GPU가 명령을 다 마치면 그제서야 펜스의 값을 1 올림 Signal
CPU는 펜스의 값이 서로 같으면 ( Event가 True로 바뀌면서 깨어남 )
다시 명령을 만들고 자신의 값을 다시 1 올림

CPU에 메모리를 할당하는 법은 new, malloc등 동적할당
리소스는 비디오 메모리에 메모리를 할당하는 것
Direct3D에서는 3가지 형태로 리소스를 나눠서 제공함
1. 커밋 리소스
2. 예약 리소스 (Reserve)
3. 위치 리소스 (Place)
보통 커밋 리소스만 사용, 특징으로는 가상 메모리 공간을 생성해주고 관리
가장 쉽게 메모리를 할당하고 사용할 수 있음

서술자(Descriptor) == View
어떤 리소스를 설명하는 자료구조를 담고있는 메모리
서술자 힙을 통해 서술자를 만들 수 있음
모든 리소스는 파이프라인에 바인딩(Set)이 되어야 함
모든 리소스들은 쉐이더가 직접 파이프라인에 연결되는 것이 아닌
리소스는 어딘가에 있고 이것에 대한 뷰가 파이프라인에 연결이 되야 함(set을 통해)
뷰에는 리소스에 접근할 수 있는 포인터가 있는 형태

모든 서술자 힙에 있는 서술자들을 엑세스하기 위해서는 그 테이블의 인덱스들을
(메모리 주소)를 가져다가 써야 함 그러나 CPU핸들, GPU핸들이 있음
CPU는 서술자를 통해 비디오 메모리(가상 메모리 공간)에 무엇인가를 써야 함
그렇기 때문에 CPU에서 접근할때 쓰는 주소(핸들)와 
GPU에서 접근할때 쓰는 주소(핸들)가 다를 수 있음
따라서 각각 핸들을 통해 시작 메모리 주소를 가져오고 서술자에 크기만큼
인덱스를 이동시켜서 사용하면 됨
Device의 Create함수를 사용해서 서술자 힙 생성
서술자 힙을 통해서 서술자들의 메모리를 할당받고 저장
Create함수로는 타입을 하나밖에 못만들기 때문에 여러 타입의 서술자 힙이
필요하다면 필요한만큼 서술자힙을 생성해줘야 함
서술자 힙 하나를 만들면 각각의 서술자의 타입도 같아야 함
그러나 CBV_SRV_UAV의 경우는 섞일 수도 있음 나머진 안섞임






























